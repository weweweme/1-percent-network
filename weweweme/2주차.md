## 1.3. 전 세계의 DNS 서버가 연대한다

### 1.3.1. DNS 서버의 기본 동작

![DNS 조회 메시지](http://www.ktword.co.kr/img_data/4889_1.jpg)

- DNS 서버의 기본 동작은 클라이언트에서 조회 메시지를 받고 응답하는 형태이다.

#### 리소스 레코드(RR; Resource Record)
- 조회 메시지에는 이름, 클래스, 타입 등 세 가지 데이터가 포함되어 있으며 이를 리소스 레코드라고 한다.
- 이름 : 도메인 이름을 나타내며, 일반적으로 웹 서버의 위치나 메일 서버 등의 리소스를 찾기 위해 사용된다.
  - 웹 서버 : www.example.com
  - 메일 주소에서 @ 뒷부분 : example.com
- 클래스 : 네트워크의 종류를 나타낸다.
  - 인터넷 클래스 : IN (거의 표준처럼 사용되고 있음)
- 타입 : 이름에 어떤 타입의 데이터가 지원되는지를 나타낸다.
  - A: IPv4 주소를 나타낸다(192.0.2.1).
  - AAAA: IPv6 주소를 나타낸다 (2001:0db8::1).
  - MX: 메일 교환기를 나타낸다(mail.example.com).
  - CNAME: 다른 도메인 이름을 나타낸다(www.example.com 은 example.com 으로 매핑).
  - 그 외 다양한 타입에 대한 정보는 다음의 [링크](https://docs.aws.amazon.com/ko_kr/Route53/latest/DeveloperGuide/ResourceRecordTypes.html)를 참고한다.

> 예시
>
> - www.example.com 이라는 주소에 해당하는 IP를 찾는다 가정한다면 클라이언트는 다음의 정보를 송신한다.
> - 이름 : www.example.com
> - 클래스 : IN
> - 타입 : A 또는 AAAA
>   - 클라이언트가 IPv4를 원하면 A, IPv6을 원한다면 AAAA 타입을 선택한다.
> - 리소스 레코드 : www.example.com, IN, A 또는 AAAA 등이 리소스 레코드에 해당한다.

- 클라이언트가 DNS에 조회 메시지를 보내면, DNS는 해당 정보에 해당하는 등록된 정보를 찾아 이름, 클래스, 타입 세 가지가 일치하는 것을 찾는다.

### 1.3.2. 도메인의 계층

![도메인 계층 구조 1](https://velog.velcdn.com/images%2Fckstn0777%2Fpost%2F165b7038-84eb-4d41-8aa2-57226f885435%2Fimage.png)
![도메인 계층 구조 2](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F999AE3335A1FAFA91F)

- 인터넷에는 막대한 수의 서버가 존재하기에, 조회 메시지를 받은 DNS 서버에 정보가 존재하지 않을 수 있다.
- DNS 서버는 계층적 구조를 가진 다른 DNS 서버와 협력하여 정보를 찾아낸다.
- 도메인 이름은 계층적 구조를 가지고 있으며, 각 계층은 점 (.)으로 구분된다.
  - www.example.com에서 com은 최상위 도메인, example은 두 번째 레벨 도메인, www은 세 번째 레벨 도메인이다.
- 계층 구조를 취함으로서 빠르고 효율적인 검색을 가능하게 한다. 
  - 질의가 명확하게 특정 서버 또는 서버 그룹에게만 전달되기 때문에, 모든 서버를 검색할 필요가 없어진다.
- DNS에서 취급하는 이름의 계층은 오른쪽에서 왼쪽으로 읽힌다. 즉, 오른쪽에 위치한 이름이 상위 계층을 의미한다.

### 1.3.3. 담당 DNS 서버를 찾아 IP 주소를 가져온다

- 핵심은 액세스 대상의 웹 서버가 어느 DNS에 등록되어 있는지 찾아내는 것이다.
- 찾아내기 위해 고안한 방법이 바로 계층 구조이다.

#### 루트 도메인(Root Domains)
- 루트 도메인은 DNS(Domain Name System) 계층 구조의 가장 상위에 위치한다.
- 루트 도메인 자체는 보통 빈 문자열로 표현되며, 모든 도메인 이름의 끝에 암묵적으로 존재한다. 
  - 일반 사용자는 이를 보통 볼 일이 거의 없다.
  > www.google.com. 에서 마지막의 '.'이 루트 도메인을 나타낸다.
- 루트 네임 서버는 루트 도메인을 관리하며, 하위 도메인의 정보를 알고 있는 TLD 서버를 가리킬 수 있다.

#### 최상위 도메인 (TLDs; Top-Level Domains)
- 최상위 도메인은 도메인 이름의 가장 오른쪽에 위치한 부분이다.
- 일반적으로 두 종류의 TLD가 있다.
  - 일반 도메인(gTLDs; Generic Top-Level Domains) : 제한 없이 누구나 등록할 수 있는 도메인 (.com, .org, .net 등)
  - 국가 도메인(ccTLDs; Country Code Top-Level Domains) : 특정 국가 또는 지역에 할당된 도메인 (.us, .kr, .uk 등)

![DNS 서버와 네임 서버에 의한 IP 주소 조회](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbwDkIw%2FbtqNVTGV9Ar%2FD6w3guBAUsphSffuQagCkk%2Fimg.png)

- 도메인 계층을 따라 질의 과정을 반복하여 찾고자 하는 도메인의 IP 주소를 찾는데, 그 과정은 다음과 같다.
  1. 사용자 질의 : 웹 브라우저에 www.google.com을 입력하면, 사용자의 컴퓨터가 DNS 서버에 IP 주소를 물어본다.
  2. 루트 서버 확인 : DNS 서버는 루트 네임 서버에 가서 어디서 IP 정보를 찾을 수 있는지 물어본다.
  3. TLD 서버 확인 : 루트 서버는 .com 네임 서버로 가라고 가이드하고, DNS 서버는 그곳에서 google.com의 DNS 서버 정보를 얻는다.
  4. 최종 IP 주소 확인 : DNS 서버는 google.com의 DNS 서버에 가서 www.google.com의 IP 주소를 얻는다.
  5. IP 주소 제공 : 이제 DNS 서버는 얻은 IP 주소를 사용자에게 전달한다.
  6. 캐싱 : 같은 요청이 또 들어오면, 이전에 찾은 정보를 빠르게 제공하기 위해 IP 주소를 임시 저장한다.
    - 이 임시 저장된 정보는 TTL(Time-To-Live)이라는 시간 값에 따라 일정 시간 동안만 유효하다.

### 1.3.4. DNS 서버는 캐시 기능으로 빠르게 회답할 수 있다

- DNS 서버는 한 번 조회한 도메인 이름과 관련된 정보를 캐시에 저장하여, 동일한 질의가 다시 들어올 경우 빠르게 답변할 수 있다.
- 저장된 정보에는 **Time-to-Live(TTL)** 이라는 유효 기간이 있어, 이 기간이 지나면 자동으로 캐시에서 삭제된다.
- 도메인의 정보가 변경된 경우, 변경된 정보가 캐시에 반영되기 전까지는 오래된 정보가 사용될 수 있다. 따라서 캐시 정보는 항상 최신이라고 단언할 수 없다.
- 일반적인 DNS 조회에서는 캐시에서 정보가 반환되었는지, 아니면 원래의 DNS 서버에서 반환되었는지에 대한 정보는 명시적으로 제공되지 않는다.
  - 이 정보는 디버깅이나 서버 관리를 위한 도구를 통해서만 일반적으로 확인할 수 있다

## 1.4. 프로토콜 스택에 메시지 송신을 의뢰한다

### 1.4.1. 데이터 송 수신의 동작 개요

- IP 주소를 찾은 뒤에는, 이 정보를 바탕으로 대상에게 데이터를 송신하도록 OS 내부의 프로토콜 스택에 의뢰한다.
- DNS 서버에 IP 주소를 조회하는 과정과는 별개로, 실제 데이터의 송 수신을 위해 Socket 라이브러리의 모듈을 사용할 수 있다.
- Socket 라이브러리를 이용한 데이터 송 수신은 컴퓨터 사이에 데이터 통로를 만들며, 이 통로를 통해 양방향으로 데이터가 전송된다.
- 이러한 데이터 통로를 구성하는 동작은 필수적이다.
- 데이터 통로의 양 끝에는 '소켓'이라는 데이터의 출입구가 위치한다. 소켓의 종류(TCP/UDP)와 사용할 포트를 선택하는 것이 필요하다.
- 클라이언트와 서버측 양쪽에서 소켓을 만들고, 클라이언트측 소켓은 서버측의 소켓에 연결을 수립한다.
- 통신이 끝나면, 데이터 통로는 분리된다. 특히 TCP의 경우, 양쪽 모두에서 정확한 연결 해제 과정을 거친다.
- 통신 프로세스 정리
  1. 소켓을 만들고, 종류와 포트를 선택한다.
  2. 클라이언트측의 소켓이 서버측의 소켓에 연결을 수립한다.
  3. 데이터를 양방향으로 송 수신한다.
  4. 통신이 완료되면, 데이터 통로를 분리하고 소켓을 해제한다.
  5. 이러한 과정은 OS 내부의 프로토콜 스택에서 처리된다.

### 1.4.2. 소켓의 작성 단계

- 클라이언트 측에서 소켓을 생성할 때, 생성된 소켓을 식별할 수 있는 **디스크립터** 가 반환되어 메모리에 저장된다.

#### 디스크립터(Descripter)

- 운영 체제가 자원을 관리하기 위해 사용하는 일종의 식별자이다.
- 파일, 소켓, 파이프 등 다양한 입출력 자원에 대한 엑세스를 제어할 때 사용된다.
- 디스크립터는 일반적으로 정수 형태의 값으로, 이 값은 특정 자원을 유일하게 식별하기 위해 운영 체제에 의해 할당됩니다.
  - 예를 들어, 소켓을 생성하면 운영 체제는 그 소켓에 대한 디스크립터를 반환합니다. 이 디스크립터를 통해 소켓에 데이터를 보내거나 받을 수 있습니다.
- 디스크립터는 메모리에 저장되며, 프로그램이 해당 자원을 다룰 때 이 디스크립터를 참조합니다.
- 운영 체제는 디스크립터 테이블을 사용하여 모든 할당된 디스크립터와 그에 연결된 자원을 추적합니다.

### 1.4.3. 파이프를 연결하는 접속 단계

- 클라이언트는 생성한 소켓을 사용해 서버에 접속하도록 운영 체제의 프로토콜 스택에 요청한다.
- Connect 함수를 호출하여 서버에 접속을 시도한다.
- Connect 함수 호출 시 필요한 주요 변수는 디스크립터, 서버의 IP 주소, 그리고 서버의 포트 번호이다.
  - 디스크립터는 소켓 생성 시에 클라이언트 애플리케이션에 반환되는 식별자다. 이 디스크립터는 connect 함수를 호출할 때만 사용되며, 서버에는 전달되지 않는다.
  - IP 주소는 DNS 서버를 통해 얻은 액세스 대상 서버의 주소이다.
  - 서버의 포트 번호는 서버에서 실행되는 특정 서비스나 애플리케이션에 접속하기 위해 필요하다. 일반적으로 이는 애플리케이션의 표준 포트 번호를 사용한다.
- 클라이언트의 포트 번호는 Connect 호출 시 프로토콜 스택이 동적으로 할당하거나 지정할 수 있다. 이 포트 번호는 서버에 접속 요청을 할 때 함께 전달된다.

### 1.4.4. 메시지를 주고받는 송 수신 단계

- 연결된 소켓을 통해 서버의 소켓으로 데이터를 전송한다.
- Write 함수를 호출하여 데이터 전송을 수행한다.
- 애플리케이션은 전송할 데이터를 메모리에 준비한다.
  - 예를 들어, 사용자가 입력한 URL을 바탕으로 생성된 HTTP 리퀘스트 메시지가 이에 해당한다.
- Write 함수 호출 시에는 디스크립터와 전송할 데이터를 지정한다.
- 프로토콜 스택은 이 데이터를 서버로 전송한다.
- 서버는 수신 동작을 실행하고, 받은 데이터를 처리한 후 적절한 응답 메시지를 반환한다.
- 데이터 수신 시에는 Socket 라이브러리의 Read 함수를 사용한다.
  - 수신한 데이터를 저장하기 위한 메모리 영역을 수신 버퍼라고 부른다.
- 수신 버퍼는 애플리케이션 프로그램이 사용하는 메모리 영역이므로, 데이터가 수신 버퍼에 저장된 시점에서 애플리케이션이 그 데이터를 접근할 수 있다.

### 1.4.5. 연결 끊기 단계에서 송 수신이 종료된다

- 클라이언트가 데이터 수신을 완료하면 송 수신 동작은 끝난다.
- 클라이언트는 Close 함수를 호출하여 연결을 종료하고, 소켓에 할당된 리소스가 운영 체제에 반환된다.
  - 이로써, 서버와 클라이언트 간의 연결 파이프가 분리된다.

#### HTTP 프로토콜에서의 연결 종료

- 일반적으로 HTTP/1.0에서는 웹 서버가 응답 메시지의 송신을 완료하면 Close를 호출하여 연결을 끊는다.
  - HTTP/1.1 버전부터는 [keep-alive](https://etloveguitar.tistory.com/137) 메커니즘을 통해 연결을 유지할 수도 있다.
- 웹 서버가 먼저 Close를 호출하면, 클라이언트는 이 정보를 받아 Read 함수를 호출할 때 0을 반환받아 연결이 종료되었음을 확인한다.
  - 이러한 동작은 HTTP 프로토콜에 국한된 사항일 수 있다.
- 연결이 종료되었음을 확인한 클라이언트는 그 후 자신도 Close를 호출하여 연결을 종료하고, 리소스를 반환한다.

![소켓의 송 수신 과정](https://velog.velcdn.com/images/dogfootbirdfoot/post/7a1416ca-3a11-49b5-bb06-e3ea99accda8/image.jpg)

---

# 참고자료
- [DNS 질의 메시지 - kt정보통신기술용어해설](http://www.ktword.co.kr/test/view/view.php?m_temp1=4889)