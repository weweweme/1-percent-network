# Chapter 2 : TCP/IP의 데이터를 전기 신호로 만들어 보낸다 - 프로토콜 스택과 LAN 어댑터의 탐험

## 2.1. 소켓을 작성한다


### 2.1.1. 프로토콜 스택의 내부 구성
- 서버에 메시지를 송출하기 위해서는 **네트워크 제어용 소프트웨어(프로토콜 스택)** 와 **네트워크용 하드웨어(LAN 어댑터)**가 동작을 수행한다.

![TCP/IP 계층](https://velog.velcdn.com/images/pwolong/post/394741dd-f3c8-4bd4-953d-37659d170a5b/image.png)

- TCP/IP 소프트웨어는 계층 구조이고, 위의 계층이 아래의 계층에 작업을 의뢰하도록 되어 있다.
  - 네트워크 애플리케이션은 브라우저, 서버 등이 여기에 해당하며, 여기부터 Socket 라이브러리를 이용, 데이터 송・수신 등의 일을 의뢰한다.
  - OS 내부에는 TCP 혹은 UDP 프로토콜을 사용하여 데이터 송・수신을 담당하여 동작을 수행한다.
    - 브라우저나 메일 등 일반적인 애플리케이션은 TCP를 사용한다.
    - DNS 서버에 대한 조회 등 짧은 제어용 데이터는 UDP를 사용한다.
  - 그리고 IP 프로토콜을 사용하여 패킷 송・수신 동작을 제어한다.
    - 인터넷에서 데이터를 운반할 때는 패킷이라는 형태로 운반하는데, 이 패킷을 통신 상대까지 운반하는 것이 IP의 역할이다.
    - IP 내부에는 **ICMP** 와 **ARP** 라는 프로토콜을 다루는 부분이 있다.
  - LAN 드라이버는 LAN 어댑터(또는 네트워크 카드)의 하드웨어를 제어하여 실제로 데이터 패킷을 송수신한다.

#### ICMP(Internet Control Message Protocol)
- 네트워크 장비 간에 오류 메시지나 정보를 전달하는 프로토콜이다.
- ping 명령어에 사용되며, 네트워크 연결 상태를 확인할 수 있다.
- 목적지 도달 불가나 시간 초과 등의 문제를 알리는데 사용된다.

#### ARP(Address Resolution Protocol)
- 로컬 네트워크에서 IP 주소를 해당 MAC 주소로 변환하는 프로토콜이다.
- 네트워크 상에서 장비가 처음 통신할 때 MAC 주소를 알아내기 위해 사용된다.
- 알아낸 IP와 MAC 주소의 매핑 정보를 ARP 테이블에 저장한다.
- ARP 요청은 브로드캐스트 방식으로 전송되며, 이를 통해 특정 IP 주소를 가진 장비를 찾는다.
  - 브로드캐스트(Broadcast) : 네트워크 내의 모든 장비에 데이터를 전송하는 방식이다.
- ARP 응답은 유니캐스트 방식으로 전송되며, 요청을 보낸 장비만이 이 응답을 받는다.
  - 유니캐스트(Unicast) : 특정한 하나의 장비에만 데이터를 전송하는 방식이다.

#### MAC 주소(Media Access Control Address)
- 하드웨어 장치를 고유하게 식별하기 위한 주소이다.
- 네트워크 카드에 고정적으로 할당된다.
- 로컬 네트워크에서 장치를 구분하는 데 사용된다.
- 6바이트 (48비트) 길이이며, 16진수로 표현된다 (00:1A:2B:3C:4D:5E)


### 2.1.2. 소켓의 실체는 통신 제어용 제어 정보
- 프로토콜 스택은 내부에 제어 정보를 기록하는 메모리 영역을 가지고 있으며, 여기에 통신 동작을 제어하기 위한 제어 정보를 기록한다.
  - 제어 정보에는 상대의 IP 주소, 포트 번호, 통신 프로세스의 진행 상태 등이 기록된다.
  - 해당 메모리 영역은 주로 OS의 커널 공간에 위치한다.
- 소켓은 개념적인 의미이며, 이 제어 정보를 소켓의 실체라고 생각하거나, 해당 메모리 영역이 소켓의 실체라고 생각해도 좋다.
  - TCP는 스트림 소켓, UDP는 데이터그램 소켓이라고도 부른다.
  - 소켓 타입에 따라 제어 정보와 동작 방식이 달라질 수 있다.
- 프로토콜 스택은 이 제어 정보를 참조하면서 동작한다.


### 2.1.3. Socket을 호출했을 때의 동작

#### 애플리케이션과 프로토콜 스택의 상호작용 과정

![메시지 송신 동작](https://user-images.githubusercontent.com/46305139/95991595-ea48ec00-0e67-11eb-93fa-b16d45bf2a4b.png)

1. DNS 요청 : 애플리케이션은 웹 서버에 접속하기 전에 종종 DNS 서버에 도메인 이름 해석을 요청한다.
  - 이 과정은 UDP 또는 TCP를 사용할 수 있으며, 대부분의 경우 UDP가 먼저 사용된다.
2. 소켓 생성 : 애플리케이션은 TCP 또는 UDP 소켓을 생성한다.
  - TCP의 경우, 애플리케이션은 소켓 API를 사용하여 명시적으로 연결을 설정하고 종료한다.
  - UDP의 경우, 연결 설정이 필요 없다.
3. 메모리 할당 : 프로토콜 스택은 애플리케이션의 데이터 송수신을 위해 필요한 메모리 영역을 확보한다.
  - 이 메모리는 보통 여러 버퍼와 큐 형태로 관리된다.
4. 데이터 송수신 : 애플리케이션은 소켓 API를 통해 데이터를 전송하거나 수신한다.
  - TCP의 경우, 데이터는 잘게 쪼개져서 패킷 형태로 전송되며, 웹 서버 측에서 다시 조립된다.
  - UDP의 경우, 데이터는 더 단순한 형태로 전송되며, 조립 과정이 필요하지 않다.
5. 연결 종료 : TCP의 경우, 데이터 송・수신이 끝난 후 애플리케이션은 연결을 명시적으로 종료할 수 있다.



## 2.2. 서버에 접속한다
- 클라이언트의 소켓은 서버측의 소켓에 접속하는 단계를 거친다. 이는 TCP의 경우에 특히 중요하다.


### 2.2.1. 접속의 의미

#### TCP의 경우
- 애플리케이션은 소켓을 생성한 뒤, Connect 함수를 호출하여 서버에 접속을 시도한다.
- 초기 소켓 생성 시에는 통신 상대가 누구인지 알 수 없다.
- Connect 함수 호출 이후에 상대의 IP 주소와 포트 번호를 프로토콜 스택에 전달한다.
- 서버측의 프로토콜 스택도 소켓을 생성하는 것만으로는 통신 상대를 알 수 없다.
- 클라이언트가 서버에 자신의 정보와 연결 의도를 전달하는 3-way-handshake 과정을 거친다.
- 접속의 첫 단계에서는 상대와 제어 정보를 주고받는다. 주로 TCP 헤더에 명시되며, 시퀀스 번호나 ACK 번호 등을 포함한다.
- 접속을 할 때 필요한 메모리 영역을 **버퍼 메모리** 라고 부른다. 이 메모리는 데이터를 일시적으로 저장한다.

#### UDP의 경우
- UDP에서는 명시적인 **접속** 단계가 없다.
- 애플리케이션은 소켓을 생성하면 바로 데이터를 전송할 수 있다.
- 통신 상대의 정보는 각 패킷을 전송할 때마다 지정한다.
- 서버측의 프로토콜 스택도 클라이언트와 마찬가지로 명시적인 접속 단계 없이 데이터를 수신할 수 있다.
- 메모리 영역(버퍼 메모리)는 여전히 필요하지만, 이는 데이터 송수신 도중에 확보나 변경이 이루어질 수 있다.

### 2.2.2. 맨 앞부분에 제어 정보를 기록한 헤더를 배치한다
- 제어 정보란 데이터 통신에서 사용되는 메타데이터의 일종이다. 
  - 메타데이터란 데이터에 대한 데이터로서 예시로 원본 데이터의 구조, 특성, 위치, 사용 방법 등이 있다.
- 데이터의 전송 방법, 통신 상태, 보안 등을 관리하기 위한 데이터이다.
- 클라이언트와 서버간 주고 받는 제어 정보는 패킷의 헤더에 부착되어 클라이언트와 서버 사이에서 주고 받는다.
- 프로토콜 스택을 제어하기 위한 제어 정보는 애플리케이션에서 발생한 데이터나 통신 상대로부터 받은 데이터 등이 포함되며 송・수신 동작과 관련된 진행 상황도 기록한다.

![UDP 패킷 구조](http://www.ktword.co.kr/img_data/323_1.JPG)
![UDP 헤더의 포맷](http://www.ktword.co.kr/img_data/323_2.jpg)

#### UDP와 제어 정보
- UDP는 연결 지향적이지 않으므로, SYN, ACK와 같은 플래그가 없다.
- UDP 헤더는 주로 포트 번호와 길이, 체크섬 등의 필드로 구성된다.

#### UDP 헤더의 구성요소
  - 발신/수신 포트 번호
    - 16비트의 포트 번호를 사용
  - 길이
    - 바이트 단위로 표시
    - 최소값 : 8바이트(헤더만 포함될 때)
    - 최대값 : 65,535 바이트(길이 필드가 16비트이기 때문에)
    - IP 제한에 의해 실질적인 최대 크기는 65,507 바이트
      - UDP 데이터그램은 IP 패킷 내에 캡슐화되어 전송된다.
      - IP 헤더는 일반적으로 20 바이트를 차지하며, UDP 헤더는 8 바이트를 차지한다.
      - 65,535 - 20 - 8 = 65,507
  - 체크섬
    - 선택 항목, 에러 검출을 위해 사용
    - 값이 0이면 수신측에서 체크섬 계산을 하지 않음
    - 자세한 설명은 [링크](http://www.ktword.co.kr/test/view/view.php?m_temp1=1477&id=744)로 대체한다


![TCP 헤더의 포맷](http://www.ktword.co.kr/img_data/1889_1.jpg)

#### TCP와 제어 정보
- 통신 과정에서 필요한 데이터나 서로의 상태 등을 주고 받는다. 예를 들면, ACK 또는 SYN 플래그가 이에 해당한다.
  - ACK(Acknowledgment) : 데이터가 성공적으로 수신되었다는 것을 확인하기 위한 역할이다. 이 플래그가 설정되면, 수신자는 전송자에게 데이터를 잘 받았다고 알린다.
  - SYN(Synchronize) : 새로운 연결을 시작할 때 사용된다. 일반적으로 클라이언트가 먼저 이 플래그가 설정된 패킷을 서버에게 보낸다. SYN 플래그가 설정되면, 해당 쪽이 상대방에게 연결을 시작하겠다는 요청을 보내는 것으로 해석된다.

#### TCP 헤더 구성 요소
- TCP 헤더 크기: 최소 20바이트 ~ 최대 60바이트
- 발신/수신 포트 번호(16비트)
  - IP 주소와 포트 번호로 구성된 소켓 주소를 생성한다.
  - 이를 통해 서버와 클라이언트 간 통신의 대상이 되는 특정 프로세스를 식별한다.
- 순서 번호 (Sequence Number, 32비트)
  - TCP 프로토콜에서는 데이터를 바이트 단위로 보낼 때 각 바이트에 일련번호를 붙인다. 이 일련번호를 통해 수신자는 데이터의 순서를 알 수 있고, 누락 또는 중복을 검사한다.
  - 순서 번호는 데이터의 신뢰성을 보장하기 위해 사용된다. 수신한 데이터의 순서 번호를 확인하여 누락된 데이터가 없는지, 모든 데이터가 올바른 순서로 도착했는지 검증한다.
  - 순서 번호는 32비트의 필드에 저장되므로, 가능한 값의 범위는 0부터 2의 32승 - 1 (약 4GB)이다.
  - TCP 연결이 처음 시작될 때 순서 번호는 일반적으로 무작위 값에서 시작하며 이를 ISN(Initial Sequence Number)이라 한다. 그 후에는 데이터를 전송할 때마다 순서 번호가 증가한다. 
  - 2의 32승 - 1에 도달하면 순서 번호는 0으로 돌아간다.
- 확인응답 번호 (Acknowledgement Number, 32비트)
  - 수신자가 송신자에게 다음에 받을 데이터를 알려준다.
  - 마지막으로 성공적으로 수신한 데이터의 순서 번호에 1을 더한 값을 넣는다.
  - 확인응답 번호를 통해 수신자는 송신자에게 특정 데이터를 올바르게 받았다고 알린다. 이를 통해 송신자는 해당 데이터에 대한 재전송이 필요 없음을 확인할 수 있다.
  - 이 필드도 32비트의 필드에 저장되므로, 가능한 값의 범위는 0부터 2의 32승 - 1 이다.
- 헤더 길이 (HLEN, 4비트)
  - 헤더 길이 필드는 실제 헤더의 길이를 4바이트 단위로 표현한다. 
  - 이 필드에 저장되는 숫자를 통해 해당 TCP 헤더가 몇 개의 4바이트 덩어리로 이루어져 있는지를 알 수 있다.
    > 만약 헤더 길이 필드의 값이 5라면, 5 (헤더 길이 필드 값) x 4 (하나의 덩어리 크기) = 20바이트 (실제 헤더의 길이)

    > 만약 헤더 길이 필드의 값이 15라면, 15 (헤더 길이 필드 값) x 4 (하나의 덩어리 크기) = 60바이트 (실제 헤더의 길이)
- 플래그 비트 8개 : CWR, ECE, URG, ACK, PSH, RST, SYN, FIN
  - TCP 연결의 다양한 상태와 제어를 위한 플래그이다.
  - CWR(Congestion Window Reduced) : 이 플래그는 네트워크 혼잡이 발생했을 때 송신자가 혼잡 윈도우 크기를 줄였음을 수신자에게 알리는 데 사용되며 수신자는 혼잡 상황이 완화되었다고 판단할 수 있다.
  - ECE(ECN-Echo) : ECE 플래그는 혼잡이 발생했음을 나타내거나, CWR 플래그를 받은 것에 대한 응답으로 사용된다. ECE 플래그가 설정된 패킷을 받으면, 이는 네트워크에서 혼잡이 발생했음을 의미한다.
  - URG(Urgent Pointer) : 긴급한 데이터가 있다고 알리며, 이 플래그가 활성화되면 긴급 포인터 필드가 유효해진다.
    - 긴급한 데이터란 네트워크 통신 중에 특별히 빠르게 처리되어야 하는 데이터를 의미한다.
      > 실시간 멀티플레이어 게임에서, 중요한 게임 이벤트나 행동(게임 내 구매, 캐릭터의 중요한 동작 등)이 실행되어야 할 때 사용된다.

      > 보안 패치나 중요한 소프트웨어 업데이트를 즉시 적용해야 하는 상황에서 사용될 수 있다.

      > 온라인 경매에서 마지막 순간의 입찰 정보를 빠르게 처리해야 할 때 사용된다.

  - ACK(Acknowledgement) : 수신한 데이터를 정상적으로 받았다고 상대방에게 알린다. 이 플래그가 활성화되면, 확인응답 번호 필드는 다음에 수신하길 원하는 바이트의 순서 번호를 가진다.
  - PSH(Push Function) : 이 플래그가 활성화되면, 버퍼링 없이 패킷을 애플리케이션 레이어로 즉시 전달해야 함을 나타낸다.
    - 일반적으로 사용자가 데이터를 즉시 보내고 싶을 때나, 버퍼가 꽉 찼을 때 활성화된다.
  - RST(Reset the Connection) : 연결에 문제가 발생했을 때, 연결을 초기화하기 위해 사용된다.
    - 유효하지 않은 패킷을 받았거나 예상치 못한 패킷을 받았을 때 활성화될 수 있다.
  - SYN(Synchronize Sequence Numbers) : 새로운 연결을 설정하기 위해 초기 시퀀스 번호를 동기화하는 단계에서 사용된다.
  - FIN(Finish) : 연결을 종료하기 위한 절차, 즉 4-way-handshake를 시작하기 위해 사용된다.
- 윈도우 크기 (Window Size, 16비트)
  - TCP에서 윈도우는 데이터 통신에서 일종의 버퍼 또는 데이터전송의 허용 범위를 의미한다.
  - 수신자가 현재 얼마나 많은 데이터를 받을 수 있는지 나타낸다.
  - 윈도우 크기를 조절함으로써 TCP는 네트워크의 혼잡 상태나 수신자의 처리 능력에 따라 데이터 전송을 최적화한다.
- 체크섬 (Checksum, 16비트)
  - 데이터의 무결성을 확인하기 위한 값이다.
- 긴급 포인터 (Urgent Pointer, 16비트)
  - 긴급 포인터는 긴급한 데이터의 위치나 범위를 지정하는 역할을 하여, 수신 측이 해당 데이터를 적절히 처리할 수 있도록 돕는다.
  - 긴급 데이터의 마지막 바이트에 대한 일련번호를 표시한다.
  - 긴급 포인터 필드는 TCP 헤더 내에 있으며, 어디까지가 긴급한 데이터인지를 지정한다. 
  - 수신 측은 긴급 포인터를 사용하여 이 데이터를 어떻게 처리해야 하는지 알게 된다.       
- 옵션
  - 옵션 필드는 TCP 연결의 성능과 안정성을 높이기 위한 다양한 추가 기능을 제공한다. 
  - 최대 40바이트까지 확장될 수 있다.
  - 흔히 사용되는 옵션 : MSS, Window Scaling, SACK, Timestamps, NOP, EOL
    - MSS(Maximum Segment Size) : TCP 세그먼트의 최대 데이터(페이로드) 크기를 설정한다. 이 값은 양쪽 통신 주체가 주고받을 세그먼트의 최대 데이터 크기를 결정하는데 사용되며, TCP 헤더 크기는 포함되지 않는다.
    - Window Scaling : 표준 윈도우 크기 제한(65,535바이트)을 초과하여 확장하기 위해 사용된다. 이를 통해 윈도우 크기를 2의 거듭제곱 배로 늘릴 수 있다. 이론적으로 최대 1GB까지 확장될 수 있다.
    - SACK(Selective Acknowledgements) : 송신자에게 어떤 데이터가 성공적으로 수신되었는지 자세한 정보를 제공한다. 이를 통해 패킷 손실이 발생했을 경우, 손실된 부분만 재전송할 수 있다.
    - Timestamps : 각 TCP 세그먼트에 시간 정보를 첨부하여, RTT 측정이나 다른 네트워크 성능 지표를 측정하는데 사용된다.
      - [RTT(Round Trip Time)](http://www.ktword.co.kr/test/view/view.php?nav=2&no=1687&sh=RTT)는 인터넷 상에서 송신지로부터 목적지까지 패킷이 왕복하는데 걸리는 시간을 의미한다.
    - NOP(No Operation) : 이 옵션은 연산을 수행하지 않으며, 단순히 다른 옵션 값들을 정렬하기 위한 패딩으로 사용된다.
    - EOL(End of Option List) : 옵션 목록의 끝을 나타낸다.
    
#### 보안 관련 제어 정보
- 보안은 모든 프로토콜에서 중요한 주제이며, 통신 보안을 위한 암호화와 인증 정보가 여기에 속한다.
- 대표적으로 SSL/TLS 암호화, OAuth 인증 등이 있다.
  - SSL/TLS 암호화 : Secure Socket Layer(SSL) 및 그 후속인 Transport Layer Security(TLS)는 데이터를 암호화하여 통신이 제3자에 의해 도청되거나 변경되지 않도록 한다.
    > HTTPS 프로토콜은 HTTP에 SSL/TLS 암호화를 추가하여 보안을 강화한다. 

    > 웹 브라우저의 주소창에서 'https://' 로 시작하는 웹사이트는 SSL/TLS를 사용하고 있다.
  - OAuth 인증: OAuth는 외부 서비스에서 리소스를 사용할 때 권한을 부여받는 표준 인증 방법 중 하나다. 이를 통해 사용자는 패스워드를 공유하지 않고도 특정 정보에 대한 접근을 허용할 수 있다.
    > Google로 로그인 기능은 OAuth를 통해 이루어진다. 
    
    > 이를 사용하면 사용자는 구글 패스워드를 직접 입력하지 않아도 다른 앱 또는 서비스에 로그인할 수 있다.


### 2.2.3. 접속 동작의 실체

#### UDP에서의 접속 동작
- UDP에서는 접속이라는 개념이 기본적으로 없다.
- 비연결형 프로토콜이기 때문에 특별한 연결 설정 단계 없이 데이터를 보낼 수 있다.
- 과정은 다음과 같다.
  1. 데이터 송신 : 클라이언트나 서버가 데이터를 보내기 위해 해당 데이터를 UDP 데이터그램 형태로 만든다.
  2. 주소 및 포트 지정 : 데이터그램에 목적지 IP와 포트 번호를 지정한다.
  3. 데이터 전송 : 데이터그램이 네트워크를 통해 목적지로 전송된다. 이 과정에서는 연결 상태나 데이터 도착 여부를 확인하지 않는다.

#### TCP에서의 접속 동작
- TCP에서는 접속 동작이 매우 중요하고 복잡하다.
- TCP는 3-way handshake를 통해 안정적인 연결을 확립한 후 데이터를 전송하며, 데이터의 안정성과 순서를 보장한다.
- 3-way-handshake는 다음의 과정으로 이루어진다.
  1. SYN 패킷 전송 : 클라이언트가 서버에 SYN 패킷을 전송하여 연결 요청을 한다.
  2. SYN-ACK 패킷 응답 : 서버가 클라이언트의 요청을 받고, SYN-ACK 패킷을 클라이언트에게 전송한다.
  3. ACK 패킷 전송 : 클라이언트가 서버의 SYN-ACK 패킷을 받고, 마지막으로 ACK 패킷을 서버에게 전송하여 연결을 확립한다.



## 2.3. 데이터를 송・수신한다(TCP 프로토콜 기반)
- 이 섹션은 TCP 프로토콜을 기반으로 소켓이 연결된 후 메시지를 송신하는 단계에 대해 설명한다.
- 특히, TCP는 데이터 전송의 정확성과 효율성을 위해 다음 세 가지 주요 메커니즘을 활용한다.
  - 오류제어(Error Control)
    - TCP는 데이터 패킷을 정확하게 전송하기 위해 ACK(Acknowledgement) 메시지를 사용한다.
    - 수신된 패킷이 손상되었거나 잘못된 경우, 수신측은 ACK를 보내지 않으며, 이 경우 송신측은 타임아웃 후 해당 패킷을 다시 전송한다.
  - 흐름제어(Flow Control)
    - TCP는 데이터의 흐름을 제어하기 위해 "윈도우 제어" 메커니즘을 사용한다.
    - 수신 버퍼가 가득 차지 않도록 수신 가능한 데이터 양을 조절한다.
    - 이를 통해 높은 네트워크 효율성과 빠른 데이터 전송을 가능하게 한다.
  - 혼잡제어(Congestion Control)
    - 네트워크 내의 다른 트래픽과의 충돌을 방지하기 위해 혼잡제어 알고리즘을 사용한다.
    - 예를 들어, 네트워크 혼잡 시 패킷 전송 속도를 줄이거나 패킷 크기를 조절한다.
    - 이러한 동작은 네트워크 리소스를 효율적으로 사용하며, 패킷 손실을 최소화한다.
  - 이러한 메커니즘을 염두에 두고 데이터 송・수신 과정을 살펴본다.

### 2.3.1. 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘긴다
- 애플리케이션은 송신할 데이터를 TCP 프로토콜 스택에 전달한다.
- 프로토콜 스택은 받은 데이터를 송신 버퍼 메모리 영역에 저장한다.

#### MTU와 MSS
- MTU(Maximum Transmission Unit) : 한 패킷으로 전송할 수 있는 데이터의 최대 크기를 의미하며, 패킷의 헤더가 포함되어 있다.
- MSS(Maximum Segment Size) : 헤더를 제외한 하나의 패킷으로 전송할 수 있는 데이터의 최대 크기이다.

#### 데이터 송신이 실행되는 조건
- TCP 프로토콜 스택에서는 데이터를 송신할 때 두 가지 주요 요소를 고려한다.
- 애플리케이션에서 받은 데이터가 MSS를 초과하거나 MSS에 가까운 크기까지 버퍼에 저장되면, 프로토콜 스택은 해당 데이터를 패킷으로 나누어 송신한다.
- TCP 프로토콜 스택 내부에는 타이머 기능이 있어, 일정 시간이 지나면 버퍼에 있는 데이터를 패킷으로 만들어 송신한다.

#### 효율과 지연 시간의 절충
- 패킷의 크기와 전송 타이밍 사이에서 어떤 것을 우선시할지 결정할 때는 상황에 따라 패킷 크기와 타이밍을 동적으로 조절하는 알고리즘을 사용할 수 있다.
- 패킷 크기를 크게 하면 네트워크 사용률은 높아지지만, 버퍼에 머무르는 시간이 길어져 송신 지연이 발생할 수 있다.
- 타이머를 짧게 설정하면 데이터는 빠르게 전송되지만, 패킷 크기가 작아져 네트워크 효율이 떨어질 수 있다.

![MTU와 MSS](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FBUphv%2FbtrcUkz494L%2FMVTxBa5o5QP82MCP7YmUhK%2Fimg.png)


### 2.3.2. 데이터가 클 때는 분할하여 보낸다
- 데이터가 너무 커서 한 패킷(MSS 길이 이내)에 담기지 않을 경우가 있다.
- 이 경우 송신 버퍼에 저장된 데이터가 MSS 길이를 초과하므로 버퍼의 데이터를 맨 앞부터 차례대로 MSS 크기에 맞게 분할한 후 각 조각을 패킷으로 만들어 송신한다.
- 조각을 송신하기 전에 TCP 헤더와 소켓에 기록된 제어 정보를 추가하여 패킷을 완성하고 송신한다.


### 2.3.3. ACK 번호를 사용하여 패킷이 도착했는지 확인한다
- TCP는 송신한 패킷이 수신측에 올바르게 도착했는지 확인하기 위한 메커니즘이 있다.

![SYN, ACK](https://user-images.githubusercontent.com/79291114/128603926-ae630d66-ac71-4b4d-9c0e-07923ebf23ba.png)

#### 시퀀스와 ACK 번호
- 데이터가 분할될 때, 각 조각은 통신 시작부터 몇 번째 바이트인지를 나타내는 시퀀스 번호가 부여된다.
  - **ISN(Initial Sequence Number)** 이라고도 부른다.
  - ISN은 TCP 헤더에 기록되며, 보안상의 이유로 난수를 기반으로 초기화된다.
- 수신측은 다음에 받을 예정인 시퀀스 번호를 ACK(Acknowledgment) 번호에 기록하여 송신측에 알려준다.

#### 재송신 메커니즘
- TCP는 수신한 패킷에 대응하는 ACK 번호를 받을 때까지 해당 패킷을 송신용 버퍼에 유지한다.
  - ACK 번호가 수신되지 않고 **타임아웃** 이 발생하면, 패킷이 제대로 도착하지 않았다고 판단하여 재송신한다.
  - 타임아웃은 일정 시간 내에 ACK를 수신하지 못했을 때 발생하며, 이 시간은 네트워크 상태에 따라 동적으로 조절될 수 있다.

#### 오류 복구와 계층
- TCP는 전송 계층에서의 오류 복구를 담당하여 패킷이 수신측에 안전하게 도착할 수 있도록 보장한다.
  - 이 과정에서 사용되는 것이 ACK 번호와 시퀀스 번호, 그리고 재송신 메커니즘 등이다.
  - 손실이나 지연이 예상되는 패킷에 대해서는 재송신을 통해 데이터의 정확성을 확보한다.
- 다른 계층에서 발생하는 오류 복구는 해당 계층의 프로토콜이나 메커니즘에 의해 처리될 수 있다.
  - 물리 계층에서 발생하는 신호 잡음 문제나 데이터 링크 계층에서의 프레임 오류는 각 계층의 오류 복구 메커니즘에 의해 해결될 수 있다.

#### 전송 실패와 연결 종료
- 재송신을 여러 번 시도한 후에도 패킷 전송이 실패하면, TCP는 연결을 종료하는 종료 프로세스를 거친다. 
  - 이 과정에서 애플리케이션에도 연결이 종료되었다는 것이 알려진다.

### 2.3.4. 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다
- TCP는 네트워크 혼잡 상태를 고려하여 ACK(Acknowledgment) 번호의 대기 시간을 동적으로 조정한다.

#### 네트워크 혼잡과 ACK 지연
- 네트워크가 혼잡할 경우, ACK 번호의 수신이 지연될 가능성이 높다.
  - 혼잡을 감지하면, ACK 대기 시간을 조정하는 것이 일반적이다.
- 지연된 ACK 수신으로 인한 불필요한 패킷 재전송은 네트워크 혼잡을 더욱 악화시킬 수 있다.

#### 대기 시간 설정의 중요성
- 대기 시간은 네트워크 상태, 서버의 거리, 데이터 패킷의 크기 등 여러 요인을 고려하여 적절하게 설정해야 한다.
  - 사내 LAN 환경에서는 수 밀리초 안에 ACK 번호가 수신될 수 있으나, 공용 인터넷에서는 수백 밀리초 이상 지연될 수 있다.

#### 대기 시간 조정 알고리즘
- TCP는 대기 시간을 동적으로 조정하는 알고리즘을 사용한다.
- 이를 위해 데이터 패킷의 평균 왕복 시간(RTT, Round-Trip Time)을 계산하여, ACK 번호의 대기 시간을 적절히 늘리거나 줄인다.
  - RTT 계산은 샘플 RTT와 이를 평균화한 값 등을 사용하여 수행될 수 있다.
- 최근의 네트워크 환경에서는 레이턴시를 최적화하는 다양한 노력이 이루어지고 있다. 
  - 이러한 작업은 데이터 센터, 클라우드 컴퓨팅, 실시간 스트리밍 서비스 등 다양한 분야에서 중요하다.
- TCP에서의 레이턴시 최적화에 대한 대표적 알고리즘
  - [TFO(TCP Fast Open)](https://www.geeksforgeeks.org/what-is-tcp-fast-open/) : 초기 연결 설정에 걸리는 시간을 줄이기 위해 설계되었다.
  - [QUIC(Quick UDP Internet Connections)](https://en.wikipedia.org/wiki/QUIC) : TCP보다 더 낮은 레이턴시를 목표로 하는 프로토콜이며, 현재는 주로 웹 서비스에 사용되고 있다.
  - [BBR(Bottleneck Bandwidth and RTT)](https://www.ietf.org/archive/id/draft-cardwell-iccrg-bbr-congestion-control-01.html) : 네트워크의 병목 지점을 식별하여 레이턴시를 최적화한다.
  - [ECN(Explicit Congestion Notification)](https://en.wikipedia.org/wiki/Explicit_Congestion_Notification ): 패킷의 혼잡 상태를 명시적으로 표시하여, 불필요한 패킷 드롭과 재전송을 줄이고 레이턴시를 개선한다.
- 다양한 방법으로 레이턴시를 최적화하려는 노력이 이루어지고 있다.
  - 이하에 나열된 용어나 프로토콜에 대한 자세한 설명은 첨부된 링크에서 확인할 수 있다.
  - 애플리케이션 계층에서의 최적화
    - [HTTP/2](https://en.wikipedia.org/wiki/HTTP/2)와 [HTTP/3](https://en.wikipedia.org/wiki/HTTP/3) : 헤더 압축과 멀티플렉싱을 사용하여 레이턴시를 줄인다. HTTP/3는 QUIC 프로토콜을 사용하여 레이턴시를 추가로 줄인다.
  - 데이터 링크 계층과 네트워크 계층에서의 최적화
    - [SD-WAN(Software-Defined Wide-Area Network)](https://en.wikipedia.org/wiki/SD-WAN) : 네트워크 트래픽을 동적 경로 선택, 로드 밸런싱, QoS 설정 등을 통해 최적의 경로로 라우팅하여 레이턴시를 개선한다.
  - 위치 기반 최적화
    - [CDN(Content Delivery Network)](https://www.cloudflare.com/ko-kr/learning/cdn/what-is-a-cdn/) : 사용자에게 물리적으로 가까운 서버에서 콘텐츠를 제공하여 레이턴시를 줄인다.
  - 하드웨어 및 시스템 레벨에서의 최적화
    - [Zero-Copy](https://en.wikipedia.org/wiki/Zero-copy) : 데이터를 애플리케이션 레벨에서 네트워크 카드로 직접 전송하여, 중간 복사 단계를 제거하여 레이턴시를 줄인다.
  - 프로토콜 통합을 통한 최적화
    - [SCTP(Stream Control Transmission Protocol)](https://en.wikipedia.org/wiki/Stream_Control_Transmission_Protocol) : TCP와 UDP의 장점을 모두 취한 프로토콜로, 다중 스트리밍과 더 나은 오류 복구를 통해 레이턴시를 줄인다.

#### 고대연 및 고용량 네트워크에서의 대기 시간 관리
- **LFN(Long Fat Networks)** 과 같은 고대연 및 고용량 네트워크에서는 TCP 윈도우 크기와 대기 시간이 중요한 역할을 한다.
- TCP Window Scaling 옵션은 고대연 및 고용량 네트워크에서 효율적인 데이터 전송을 가능하게 한다.
- 대역폭-지연 곱이 큰 네트워크에서 기본적으로 설정된 TCP 윈도우 크기가 작다면, 이는 TCP 연결의 최대 처리량을 제한하게 된다.
  - **대역폭-지연 곱(BDP; Bandwidth-Delay Product)** 은 네트워크의 대역폭과 지연 시간을 곱하여 계산되며, 이 값은 네트워크 경로에 동시에 존재할 수 있는 데이터의 양을 나타낸다.
  - 네트워크의 대역폭을 전부 활용하지 못하게 되어 비효율적인 상황이 발생할 수 있다.
  - 따라서 네트워크의 대역폭과 지연 시간을 고려하여 TCP 윈도우 크기를 적절히 조정하는 것이 필요하다.


### 2.3.5. 윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다
- TCP는 ACK 번호가 돌아올 때까지 윈도우 제어를 실행한다. 이를 통해 수신측의 처리 능력을 초과하지 않도록 패킷 전송이 조절된다.

#### Stop-and-Wait ARQ 방식
- 수신측은 수신 처리가 끝난 후에만 ACK 번호를 반환한다.
- 송신측은 이 ACK 번호를 받고 나서만 다음 패킷을 전송한다.
- 이 방식은 단순하지만 네트워크의 대역폭이 충분히 활용되지 않을 수 있다.
- 수신측의 TCP는 패킷을 수신하면 수신용 버퍼 메모리에 데이터를 임시로 보관한다. 만약 수신측이 느린 경우, 이 버퍼가 중요한 역할을 한다.
  - 수신 버퍼는 네트워크에서 데이터 패킷을 일시적으로 저장하는 메모리 공간이다.

#### 윈도우 제어 방식
- 여러 패킷을 동시에 처리할 수 있어 네트워크 자원을 더 효율적으로 활용한다.
- 애플리케이션에 데이터를 전달하는 속도보다 빠르게 데이터가 도착하면, 수신 버퍼는 넘쳐서 데이터가 손실될 수 있다.
- 수신측의 TCP는 처리가 끝나지 않은 상태에서도 다음 패킷을 받을 수 있도록 수신 버퍼가 설치되어 있다.
- 이를 방지하기 위해 수신측은 **윈도우 제어 방식** 을 사용하여 송신 동작을 조절한다.

#### 윈도우 사이즈 조절
- 수신 처리가 완료되고 버퍼에 빈 공간이 생기면, 그만큼의 데이터를 추가로 수신할 수 있다.
- 이 정보는 TCP 헤더의 **윈도우 필드** 를 통해 송신측에 알려진다.
- 수신 가능한 데이터 양의 최대값을 **윈도우 사이즈** 라고 부른다.
  - 만약 수신 버퍼에 남은 자리가 1MB라면, 윈도우 사이즈도 이에 맞춰 조절될 것이다.


### 2.3.6. ACK 번호와 윈도우를 합승한다
- 송・수신의 효율성을 높이기 위해 ACK 번호와 윈도우를 통지하는 타이밍을 고려해야한다.

#### 윈도우 사이즈 업데이트 타이밍
- 윈도우 업데이트가 필요한 시점은 수신측이 수신 버퍼에서 데이터를 추출하여 애플리케이션에 건네주었을 때이다.
- 송신측은 이 시점을 미리 알 수 없으므로, 수신측에서 통지해야 한다.
- 응용 프로세스가 수신 버퍼에 저장된 데이터를 빠르게 읽지 못한다면 0으로 수렴하게되며, 더이상 수신을 못하게 된다.
- 만약 수신 버퍼가 가득 차면 수신 윈도우 크기는 0으로 수렴하고, 수신과 송신 모두 정지될 수 있다.
  - 이런 상황에서 발생할 수 있는 **교착상태(Deadlock)** 를 방지하기 위해 **윈도우 프로브(Window Probe)** 가 필요하다.
  - 송신측은 주기적으로 윈도우 프로브 패킷을 수신측에 보내서 수신 윈도우의 상태를 확인한다.
  - 수신측은 이 윈도우 프로브 패킷에 대한 ACK를 보내서 송신측에 윈도우 크기 변화를 통지한다.

#### ACK 번호 업데이트 타이밍
- ACK 번호는 수신측에서 데이터를 받았을 때 내용을 검사하여 정상 수신을 확인할 수 있는 경우에만 송신측에 보낸다.

#### 통신 최적화
- 수신측은 가능한 경우 ACK 번호와 윈도우 업데이트 정보를 한 패킷에 묶어서 보내는 방법을 고려한다.
- 여러 개의 ACK 번호나 윈도우 업데이트가 연속해서 발생하면, 가장 최근의 정보만을 통지하고 중간의 정보는 생략한다. 이로 인해 통신 오버헤드를 줄일 수 있다.


### 2.3.7. HTTP 응답 메시지를 수신한다

#### 클라이언트의 동작
- 클라이언트는 서버에 리퀘스트 메시지를 보낸다.
- 리퀘스트가 성공적으로 전송된 후, 클라이언트는 서버로부터의 응답을 기다린다.
- 이를 위해, 클라이언트는 Read 함수를 호출하여 응답을 대기 상태로 들어간다.

#### 프로토콜 스택과 수신 버퍼
- 프로토콜 스택은 수신 버퍼를 사용하여 데이터를 임시 저장한다.
- 서버로부터 응답 패킷과 함께 ACK 번호가 도착하면, 프로토콜 스택은 수신 버퍼에서 데이터를 추출한다. 
  - 여기서 ACK 번호가 도착했다는 것이 데이터가 성공적으로 수신되었음을 의미한다.

#### 애플리케이션과 응답 메시지
- 만약 응답 메시지가 아직 도착하지 않았다면, 애플리케이션은 일시적으로 다른 작업을 수행할 수 없다.
- 응답 메시지가 도착하면, 프로토콜 스택은 해당 내용을 애플리케이션에 전달하며, 이후 애플리케이션은 필요한 작업을 계속 수행할 수 있다.



## 2.4. 서버에서 연결을 끊어 소켓을 말소한다
- 메시지 송・수신이 끝나면 서버에서 연결을 끊고, 클라이언트와 서버가 함께 송・수신이 끝났음을 확인하고 소켓을 말소한다.


### 2.4.1. 데이터 보내기를 완료했을 때 연결을 끊는다
- UDP는 연결이 없으므로 명시적인 연결 종료 과정이 없다. 애플리케이션은 필요 없어지면 소켓을 닫으면 된다.
- TCP 프로토콜에서 연결을 끊는 과정을 **4-way-handshake** 라고 한다.
  - 아래의 단계는, TCP의 4-way-handshake의 과정을 설명한다.

![4-way handshake](https://velog.velcdn.com/images%2Fnnnyeong%2Fpost%2Ffd5029e1-b84c-4fa3-9f7b-d5f702f1b1b9%2Fimage.png)

#### 1단계 : 서버에서 FIN 비트 설정 (상태: ESTABLISHED → FIN_WAIT_1)
- 서버는 모든 데이터 송신이 완료되었을 때 Close를 호출하여 연결을 종료하고자 한다.
- 이를 위해 서버의 프로토콜 스택은 TCP 헤더에 FIN 비트를 1로 설정한다.
- 이 패킷은 IP 계층을 통해 클라이언트에게 전송된다.

#### 2단계 : 클라이언트에서 ACK 응답 (상태: ESTABLISHED → CLOSE_WAIT)
- 클라이언트는 FIN 비트가 설정된 TCP 패킷을 수신하고, 이를 ACK로 응답한다.
- 클라이언트의 소켓 상태 정보에도 서버측이 연결을 종료하려고 한다는 것을 기록한다.

#### 3단계 : 클라이언트에서 FIN 비트 설정 (상태: CLOSE_WAIT → LAST_ACK)
- 클라이언트 애플리케이션은 모든 데이터 수신이 완료되었을 때 Read를 호출한 후, Close를 호출하여 연결을 종료하고자 한다.
- 클라이언트의 프로토콜 스택도 TCP 헤더에 FIN 비트를 1로 설정한다.
- 이 패킷은 서버에게 전송된다.

#### 4단계 : 서버에서 ACK 응답 (상태: FIN_WAIT_2 → TIME_WAIT)
- 서버는 클라이언트로부터의 FIN 비트가 설정된 패킷을 수신하고, 이를 ACK로 응답한다.
- 이 ACK 응답이 성공적으로 도착하면, 둘 사이의 연결이 성공적으로 종료된다.
- 서버는 일정 시간 동안 TIME_WAIT 상태로 머무른다.
  - 지연된 패킷이 도착할 경우 이를 처리하거나, 포트 충돌을 방지하기 위해 일정 시간 동안 머무른다.
  - TIME_WAIT 상태에서의 대기 시간은 일반적으로 2 * MSL(Maximum Segment Lifetime)로 설정되며, 이는 대체로 1~4분 사이다.


### 2.4.2. 소켓을 말소한다
- 소켓을 즉시 말소하지 않고 일정 시간 동안 대기하는 이유는 잠재적인 네트워크 오동작을 방지하기 위함이다.
- 서버가 클라이언트에게 다시 FIN 패킷을 보낼 경우, 이미 말소된 소켓의 포트가 재할당될 가능성이 있다. 이로 인해 원치 않는 연결 종료 과정이 시작될 수 있다.
- 대기 시간 동안 네트워크 상에 패킷이 어떻게 동작하는지를 관찰하며, 이 시간이 지나면 안전하게 소켓을 말소한다.
- 이 대기 시간은 일반적으로 패킷의 재전송 시간과 관련이 있으며, 몇 분 정도로 설정된다.
- 이러한 대기 시간을 통해, 잘못된 연결 종료나 데이터 손실 등의 가능성을 줄인다.


### 2.4.3. 데이터 송・수신 동작을 정리한다
- TCP 프로토콜에서의 데이터 송・수신 동작을 정리한다.

#### 소켓 작성 및 접속 대기
- 서버에서 애플리케이션을 실행하여 소켓을 생성하고, 이를 접속 대기 상태로 만든다. 클라이언트에서는 사용자가 서버에 액세스하려 할 때 소켓을 생성한다.

#### 접속 동작 시작
- 클라이언트는 SYN을 1로 설정한 TCP 헤더를 생성하여 서버에 보낸다. 이 헤더에는 시퀀스 번호와 윈도우 크기도 기록된다.
- 서버에서는 이를 받고, SYN을 1로 설정한 TCP 헤더를 클라이언트에게 돌려보낸다.
- 클라이언트는 이를 받고, ACK 번호를 기록한 TCP 헤더를 서버에 보낸다.

#### 데이터 송・수신 단계
- 클라이언트에서는 서버에 리퀘스트 메시지를 보낸다. TCP는 이 메시지를 적당한 크기로 분할하여, TCP 헤더를 추가한 후 서버에 보낸다.
- 서버에서는 이를 받고, ACK 번호를 클라이언트에 보낸다.
- 이 과정이 반복되며, 필요에 따라 윈도우 크기 정보도 갱신된다.

#### 데이터 송・수신 완료 및 연결 종료
- 서버에서 응답 메시지를 전송하면, 데이터 송・수신 단계가 완료된다.
- 서버는 FIN을 1로 설정한 TCP 헤더를 보내어 연결을 종료하려고 시도한다.
- 클라이언트는 이를 받고, ACK를 보낸다.
- 이후, 역방향으로도 같은 과정이 이루어지고, 소켓은 일정 시간 후에 말소된다.

---

# 참고자료
- [UDP; User Datagram Protocol - kt정보통신기술용어해설](http://www.ktword.co.kr/test/view/view.php?nav=2&no=323&sh=UDP+Header)
- [TCP - Wikipedia](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)
- [TCP Header; Transmission Control Protocol Header - kt정보통신기술용어해설](http://www.ktword.co.kr/test/view/view.php?m_temp1=1889)
- [Improving Performance on AWS and Hybrid Networks - AWS](https://aws.amazon.com/ko/blogs/networking-and-content-delivery/improving-performance-on-aws-and-hybrid-networks/)
- [How to Track and Drastically Lower AWS Cross-Region Latency - AWS](https://www.resilio.com/blog/aws-cross-region-latency)
- [Stop-and-Wait   Stop and Wait, Idle ARQ   정지대기 방식 - kt정보통신기술용어해설](http://www.ktword.co.kr/test/view/view.php?m_temp1=1355)